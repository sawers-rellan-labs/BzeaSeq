---
title: "Teosinte Introgression Lines Ancestry Analysis by bins"
author: "Maize Genetics Lab"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    theme: flatly
    highlight: tango
    code_folding: show
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  fig.width = 10, 
  fig.height = 6,
  dpi = 300
)
BIN_SIZE=1000000
BIN_SIZE_LABEL<-"1Mb"
```

## Overview

This document outlines a genomic ancestry analysis pipeline for maize introgression lines. The analysis identifies genomic ancestry across bins of size `r BIN_SIZE_LABEL` using the following approach:

1. **Initial Classification**: Bins with no alternative alleles (ALT_FREQ = 0) are automatically classified as "REF"
2. **Clustering**: For the remaining bins (ALT_FREQ > 0), multiple clustering methods are applied with k=3
3. **Method Comparison**: Four different clustering approaches are compared:
   - K-means with weighted ALT_FREQ
   - K-means with arcsin transformation
   - K-means with log10 transformation  
   - Gaussian mixture model
4. **HMM Smoothing**: Hidden Markov Model smoothing is applied to reduce noise and enforce biological constraints
5. **Validation**: Methods are compared for consistency and biological plausibility

## Load Required Packages

```{r load-packages}
# Load required libraries
library(dplyr)        # Data manipulation
library(ggplot2)      # Plotting
library(Ckmeans.1d.dp) # K-means clustering
library(rebmix)       # Gaussian mixture model
library(HMM)          # Hidden Markov Models
library(tidyr)        # Data reshaping
library(scales)       # Unit formatting for plots
library(ggpubr)       # Plot arrangement
library(tibble)       # Modern data frames
```

## Data Preparation and Initial Exploration

```{r create-bins}
# Read the binned allelic counts
read_freq <- read.table("~/Desktop/PN17_SID1632_bin_genotypes.tsv", header=TRUE)

# Display first few rows of the binned data
head(read_freq)

# Calculate summary statistics
IVC_mean <- mean(read_freq$INFORMATIVE_VARIANT_COUNT)
IVC_sd <- sd(read_freq$INFORMATIVE_VARIANT_COUNT)

# Display summary of bins
cat("Total number of bins:", nrow(read_freq), "\n")
cat("Average depth sum:", mean(read_freq$DEPTH_SUM), "\n")
cat("Average number of informative variants per bin:", IVC_mean, "\n")
cat("Median number of informative variants per bin:", median(read_freq$INFORMATIVE_VARIANT_COUNT), "\n")
cat("Range of informative variants per bin:", min(read_freq$INFORMATIVE_VARIANT_COUNT), "to", max(read_freq$INFORMATIVE_VARIANT_COUNT), "\n")
```

## Weighting ALT_FREQ by informative variant count

```{r weight-evidence}
# Create weightesALT_FREQ 
read_freq <- read_freq %>%
  mutate(
    ALT_FREQ_WEIGHTED = ALT_FREQ * (INFORMATIVE_VARIANT_COUNT / IVC_mean)
  )

# Visualize the relationship between informative variant count and ALT_FREQ
ggplot(read_freq, aes(x = INFORMATIVE_VARIANT_COUNT, y = ALT_FREQ)) +
  geom_point(alpha = 0.6) +
  labs(title = paste("Relationship between informative variant count and ALT_FREQ (", BIN_SIZE_LABEL, " bins)", sep=""),
       x = "Number of informative variants in bin", 
       y = "Alternative allele frequency") +
  theme_minimal()

# Compare original vs weighted frequencies
p1 <- ggplot(read_freq, aes(x = ALT_FREQ)) +
  geom_histogram(bins = 30, fill = "steelblue", color = "white") +
  labs(title = "Original ALT_FREQ distribution", x = "ALT_FREQ") +
  theme_minimal()

p2 <- ggplot(read_freq, aes(x = ALT_FREQ_WEIGHTED)) +
  geom_histogram(bins = 30, fill = "tomato", color = "white") +
  labs(title = "Weighted ALT_FREQ distribution", x = "ALT_FREQ_WEIGHTED") +
  theme_minimal()

ggpubr::ggarrange(p1, p2, ncol = 2)
```

## Zero-ALT Bin Identification

```{r identify-zero-bins}
# Check how many bins have ALT_FREQ = 0
zero_alt_bins <- sum(read_freq$ALT_FREQ_WEIGHTED == 0)
total_bins <- nrow(read_freq)

cat("Bins with ALT_FREQ_WEIGHTED = 0:", 
    zero_alt_bins, "out of", total_bins, 
    "(", round(100 * zero_alt_bins / total_bins, 1), "%)\n")

# Create a separate dataset for non-zero bins (for clustering)
non_zero_bins <- read_freq %>%
  filter(ALT_FREQ_WEIGHTED > 0)

cat("Bins with ALT_FREQ_WEIGHTED > 0 (to be clustered):", 
    nrow(non_zero_bins), "out of", total_bins,
    "(", round(100 * nrow(non_zero_bins) / total_bins, 1), "%)\n")
```

## Data Transformation for Clustering

```{r transform-nonzero-data}
# Create transformations for better clustering performance
non_zero_bins$asin <- asin(sqrt(non_zero_bins$ALT_FREQ_WEIGHTED))

# Visualize distributions of the weighted and transformed data
p1 <- ggplot(non_zero_bins, aes(x = ALT_FREQ_WEIGHTED)) + 
  geom_histogram(bins = 30, fill = "steelblue", color = "white") +
  labs(title = paste("Weighted ALT_FREQ distribution (non-zero bins, ", BIN_SIZE_LABEL, ")", sep=""), 
       x = "ALT_FREQ_WEIGHTED") +
  theme_minimal()

p2 <- ggplot(non_zero_bins, aes(x = asin)) + 
  geom_histogram(bins = 30, fill = "steelblue", color = "white") +
  labs(title = "Arcsin transformation (non-zero bins)",
       x = "asin(sqrt(ALT_FREQ_WEIGHTED))") +
  theme_minimal()


ggpubr::ggarrange(p1, p2, common.legend = TRUE)
```

## Clustering Methods Application

```{r kmeans-clustering-nonzero}
K <- 3

# Apply K-means clustering with k=3 to each transformation for non-zero bins
non_zero_bins$K <- as.factor(Ckmeans.1d.dp(non_zero_bins$ALT_FREQ_WEIGHTED, K)$cluster)
non_zero_bins$Kasin <- as.factor(Ckmeans.1d.dp(non_zero_bins$asin, K)$cluster)

# Function to relabel clusters as REF, HET, ALT based on ALT_FREQ
relabel_clusters <- function(clusters, data) {
  # Calculate mean ALT_FREQ for each cluster
  cluster_means <- tapply(data$ALT_FREQ, clusters, mean)
  
  # Order clusters by mean ALT_FREQ
  ordered_clusters <- order(cluster_means)
  
  # Create mapping from original cluster to REF, HET, ALT
  cluster_map <- rep(NA, length(unique(as.numeric(clusters))))
  cluster_map[ordered_clusters[1]] <- "REF"
  cluster_map[ordered_clusters[2]] <- "HET"
  cluster_map[ordered_clusters[3]] <- "ALT"
  
  # Apply mapping to original clusters
  return(factor(cluster_map[as.numeric(clusters)], levels = c("REF", "HET", "ALT")))
}

# Apply relabeling to each clustering method
non_zero_bins$K <- relabel_clusters(non_zero_bins$K, non_zero_bins)
non_zero_bins$Kasin <- relabel_clusters(non_zero_bins$Kasin, non_zero_bins)

# Check cluster proportions for each method
cat("K-means cluster proportions (non-zero bins):\n")
table(non_zero_bins$K) %>% prop.table() %>% round(3)

cat("\nArcsin-transformed K-means cluster proportions (non-zero bins):\n")
table(non_zero_bins$Kasin) %>% prop.table() %>% round(3)
```

## Gaussian Mixture Modeling

```{r gmm-clustering-nonzero}
# Fit Gaussian mixture model with 3 components
normalest <- REBMIX(
  Dataset = list(data.frame(Value = non_zero_bins$ALT_FREQ_WEIGHTED)),
  Preprocessing = "histogram",
  cmin = 3,  # Force 3 components
  cmax = 3,
  Criterion = "BIC",
  pdf = "normal"
)

# Assign clusters
normclu <- RCLRMIX(x = normalest)
non_zero_bins$Kgmm <- as.factor(normclu@Zp)

# Relabel Kgmm clusters
non_zero_bins$Kgmm <- relabel_clusters(non_zero_bins$Kgmm, non_zero_bins)

# Check Kgmm cluster proportions
cat("Gaussian Mixture Model cluster proportions (non-zero bins):\n")
table(non_zero_bins$Kgmm) %>% prop.table() %>% round(3)
```

## Merge Clustering Results to Full Dataset

```{r merge-results}
# Create new columns in read_freq for each clustering method
read_freq$K <- factor(NA, levels = c("REF", "HET", "ALT"))
read_freq$Kasin <- factor(NA, levels = c("REF", "HET", "ALT"))
read_freq$Kgmm <- factor(NA, levels = c("REF", "HET", "ALT"))

# Assign the non-zero bin clustering results to the main dataset
for (method in c("K","Kasin", "Kgmm")) {
  # Create an index for non-zero bins in the original data
  non_zero_idx <- which(read_freq$ALT_FREQ_WEIGHTED > 0)
  
  # Assign cluster classifications to non-zero bins
  read_freq[[method]][non_zero_idx] <- non_zero_bins[[method]]
}

# Force bins with ALT_FREQ = 0 to be "REF"
zero_idx <- which(read_freq$ALT_FREQ == 0)
for (method in c("K", "Kasin", "Kgmm")) {
  read_freq[[method]][zero_idx] <- "REF"
}

# Verify the merging worked correctly
cat("Final cluster proportions for raw K-means:\n")
table(read_freq$K) %>% prop.table() %>% round(3)
```

To compare the different clustering methods, we visualize the data in several ways:

### Scatter plots of ALT_FREQ_WEIGHTED colored by genotype

```{r scatter-plots, fig.height=12}
# Define color palette
pal <- c("REF" = "gold", "HET" = "springgreen4", "ALT" = "purple4")

# Create a function for scatter plots
create_scatter <- function(data, method_col, title) {
  data %>%
    mutate(POS = BIN_POS * BIN_SIZE) %>%
    ggplot(aes(x = POS, y = ALT_FREQ_WEIGHTED, col = .data[[method_col]])) +
        labs(title = title, x = "Position (Mb)", y = "ALT_FREQ_WEIGHTED", color = "Genotype") +
    geom_point(size = 1, alpha = 0.7) +
    scale_color_manual(values = pal) +
    facet_wrap(.~CONTIG,ncol=10, scales = "free_x", strip.position = "bottom") +
    theme_bw() +
    scale_x_continuous(labels = unit_format(unit = "", scale = 1e-6))
}

read_freq$CONTIG <-factor(read_freq$CONTIG, levels= paste0("chr",1:10))
  
# Create scatter plots for each method
p1 <- create_scatter(read_freq, "K", paste("K-means on weighted ALT_FREQ (", BIN_SIZE_LABEL, " bins)", sep=""))
p2 <- create_scatter(read_freq, "Kasin", paste("K-means on arcsin transformed ALT_FREQ (", BIN_SIZE_LABEL, " bins)", sep=""))
p3 <- create_scatter(read_freq, "Kgmm", paste("Gaussian mixture model on weighted ALT_FREQ (", BIN_SIZE_LABEL, " bins)", sep=""))


# Display all scatter plots
ggpubr::ggarrange(p1, p2, p3, ncol = 1, common.legend = TRUE)
```


## HMM Smoothing Implementation

### Theoretical Background

For maize introgression lines produced through backcrossing followed by selfing (e.g., BC2S3), we can calculate expected genotype frequencies based on Mendelian genetics:

```{r breeding-theory}
# Create mating matrices 
create_mating_matrices <- function() {
  # Backcross matrix for crossing population with AA donor
  # Each COLUMN represents offspring distribution from that parent × AA
  # Column 1: AA × AA → [1, 0, 0] (100% AA offspring)
  # Column 2: Aa × AA → [1/2, 1/2, 0] (50% AA, 50% Aa offspring)  
  # Column 3: aa × AA → [0, 1, 0] (100% Aa offspring)
  backcross_AA <- matrix(c(
    1, 1/2, 0,    
    0, 1/2, 1,    
    0,   0, 0     
  ), nrow = 3, byrow = TRUE)
  
  # Backcross matrix for crossing population with aa donor
  # Column 1: AA × aa → [0, 1, 0] (100% Aa offspring)
  # Column 2: Aa × aa → [0, 1/2, 1/2] (50% Aa, 50% aa offspring)
  # Column 3: aa × aa → [0, 0, 1] (100% aa offspring)
  backcross_aa <- matrix(c(
    0,   0, 0,    
    1, 1/2, 0,    
    0, 1/2, 1     
  ), nrow = 3, byrow = TRUE)
  
  # Selfing matrix - each individual self-fertilizes
  # Column 1: AA selfed → [1, 0, 0] (100% AA offspring)
  # Column 2: Aa selfed → [1/4, 1/2, 1/4] (25% AA, 50% Aa, 25% aa offspring)
  # Column 3: aa selfed → [0, 0, 1] (100% aa offspring)
  selfing <- matrix(c(
    1, 1/4, 0,    
    0, 1/2, 0,    
    0, 1/4, 1     
  ), nrow = 3, byrow = TRUE)
  
  return(list(
    backcross_AA = backcross_AA,
    backcross_aa = backcross_aa,
    selfing = selfing
  ))
}

# Function to calculate genotype frequencies after breeding scheme
calculate_nil_frequencies <- function(bc=2, s=3, donor_type = "aa", from = c(0,1,0) ) {
  # Input validation
  if (bc  < 0 || s < 0) {
    stop("Number of backcrosses and self generations must be non-negative")
  }
  if (!donor_type %in% c("AA", "aa")) {
    stop("Donor type must be 'AA' or 'aa'")
  }
  
  # Get mating matrices
  matrices <- create_mating_matrices()
  
  # Initial F1 generation - all heterozygous after crossing pure lines
  # Population vector: [AA frequency, Aa frequency, aa frequency]
  current_population <- matrix(from, ncol = 1)
  
  # Apply backcrosses sequentially
  if (bc > 0) {
    # Select appropriate backcross matrix based on donor type
    backcross_matrix <- if (donor_type == "aa") {
      matrices$backcross_AA
    } else {
      matrices$backcross_aa
    }
    
    # Each backcross: Matrix %*% population_vector
    # This takes weighted average of matrix columns based on current population
    for (i in 1:bc) {
      current_population <- backcross_matrix %*% current_population
      
      # Optional: print intermediate results for debugging
      if (exists("debug_nil") && debug_nil) {
        cat("After backcross", i, ": [", 
            round(current_population[1,1], 4), ", ",
            round(current_population[2,1], 4), ", ", 
            round(current_population[3,1], 4), "]\n")
      }
    }
  }
  
  # Apply selfing generations sequentially  
  if (s > 0) {
    # Each selfing: selfing_matrix %*% population_vector
    # Each column represents offspring from selfing that genotype
    for (i in 1:s) {
      current_population <- matrices$selfing %*% current_population
      
      # Optional: print intermediate results for debugging
      if (exists("debug_nil") && debug_nil) {
        cat("After self", i, ": [", 
            round(current_population[1,1], 4), ", ",
            round(current_population[2,1], 4), ", ", 
            round(current_population[3,1], 4), "]\n")
      }
    }
  }
  
  # Extract final frequencies as named vector
  final_frequencies <- as.vector(current_population)
  names(final_frequencies) <- c("AA", "Aa", "aa")
  
  return(final_frequencies)
}

# Function to return frequencies in HMM format (REF, HET, ALT)
nil_frequencies_for_hmm <- function(bc, s, donor_type = "aa", from = c(0,1,0)) {
  # Calculate raw genotype frequencies
  genotype_freqs <- calculate_nil_frequencies(bc, s, donor_type, from)
  
  # Convert to HMM format based on which allele is being introgressed
  if (donor_type == "AA") {
    # AA is the introgressed (donor) allele
    # aa represents the recurrent parent background (REF)
    # AA represents regions with donor allele (ALT)
    hmm_frequencies <- c(
      REF = genotype_freqs["aa"],  # Recurrent parent background
      HET = genotype_freqs["Aa"],  # Heterozygous regions  
      ALT = genotype_freqs["AA"]   # Donor introgression
    )
  } else {
    # aa is the introgressed (donor) allele
    # AA represents the recurrent parent background (REF)
    # aa represents regions with donor allele (ALT)
    hmm_frequencies <- c(
      REF = genotype_freqs["AA"],  # Recurrent parent background
      HET = genotype_freqs["Aa"],  # Heterozygous regions
      ALT = genotype_freqs["aa"]   # Donor introgression  
    )
  }
  names(hmm_frequencies) <- c("REF", "HET","ALT")
  return(hmm_frequencies)
}

bc2s3 <- nil_frequencies_for_hmm(bc=2,s=3)

cat("Expected genotype frequencies for BC2S3:\n")
cat("REF:", round(bc2s3["REF"], 4), "\n")
cat("HET:", round(bc2s3["HET"], 4), "\n") 
cat("ALT:", round(bc2s3["ALT"], 4), "\n")
```

### HMM Smoothing Function

```{r hmm-smoothing-function}
# Function to apply HMM smoothing to ancestry calls
smooth_ancestry_with_hmm <- function(genotypes, transitions = c(0.96, 0.04)) {
  # Convert genotypes to numeric (0=REF, 1=HET, 2=ALT)
  geno_numeric <- as.numeric(factor(genotypes, levels=c("REF", "HET", "ALT"))) - 1
  
  # Set up transition probabilities (high probability of staying in same state)
  trans_prob <- matrix(c(
    transitions[1], transitions[2]/2, transitions[2]/2,  # From REF
    transitions[2]/2, transitions[1], transitions[2]/2,  # From HET
    transitions[2]/2, transitions[2]/2, transitions[1]   # From ALT
  ), nrow=3, byrow=TRUE)
  
  # Set up emission probabilities (how likely each state produces observed genotypes)
  emiss_prob <- matrix(c(
    0.9, 0.08, 0.02,  # REF state
    0.1, 0.8, 0.1,    # HET state
    0.02, 0.08, 0.9   # ALT state
  ), nrow=3, byrow=TRUE)
  
  # Initialize HMM with BC2S3 priors
  hmm <- initHMM(c("REF", "HET", "ALT"), c("0", "1", "2"), 
                startProbs = bc2s3,  # Prior probabilities from breeding design
                transProbs = trans_prob, 
                emissionProbs = emiss_prob)
  
  # Run Viterbi algorithm to find most likely state sequence
  viterbi_path <- viterbi(hmm, as.character(geno_numeric))
  
  # Convert back to genotype calls
  smoothed_genotypes <- factor(viterbi_path, levels=c("REF", "HET", "ALT"))
  
  return(smoothed_genotypes)
}
```

### Apply HMM Smoothing

```{r apply-hmm-smoothing}
# Apply HMM smoothing to each chromosome separately
read_freq <- read_freq %>%
  group_by(CONTIG) %>%
  mutate(
    K_HMM = smooth_ancestry_with_hmm(K, transitions=c(0.95, 0.05)),
    Kasin_HMM = smooth_ancestry_with_hmm(Kasin, transitions=c(0.95, 0.05)),
    Kgmm_HMM = smooth_ancestry_with_hmm(Kgmm, transitions=c(0.95, 0.05))
  ) %>%
  ungroup()

# Ensure chromosome factor ordering
read_freq$CONTIG <- factor(read_freq$CONTIG, levels = paste0("chr", 1:10))
```

## Visualization and Method Comparison

### Single Method Visualization

```{r single-method-tile, fig.height=3}


# Create tile plot function
create_tile <- function(data, method_col, title) {
  data %>%
    mutate(
      CONTIG = factor(CONTIG, levels = paste0("chr", 1:10)),
      POS = BIN_POS * BIN_SIZE
    ) %>%
    ggplot(aes(x = POS, y = 1, fill = .data[[method_col]])) +
    geom_tile() +
    facet_wrap( .~CONTIG, ncol = 1, strip.position = "left") +
    scale_x_continuous(labels = unit_format(unit = "M", scale = 1e-6)) +
    scale_fill_manual(values = pal) +
    labs(title = title, x = "Position (bp)", fill = "Genotype") +
    ggpubr::theme_classic2(base_size = 10) +
    theme(
      legend.position = "bottom",
      strip.background = element_blank(),
      strip.text.y.left = element_text(angle = 0, hjust = 0),
      panel.spacing.y = unit(0.0, "lines"),
      axis.line.y = element_blank(),
      axis.text.y = element_blank(),
      axis.title.y = element_blank(),
      axis.ticks.y = element_blank()
    ) 
}
```

### HMM Smoothing Effect

```{r hmm-effect-comparison, fig.height=6}
# Compare before and after HMM smoothing
create_tile(read_freq, "Kgmm", paste("Before HMM Smoothing |", BIN_SIZE_LABEL, "bins")) 
create_tile(read_freq, "Kgmm_HMM", paste("After HMM Smoothing |", BIN_SIZE_LABEL, "bins"))
```

### All Methods Comparison

```{r tile-plots, fig.height=4}
# Create a combined plot for all methods including HMM
read_freq %>%
  pivot_longer(cols = starts_with("K"), names_to = "method", values_to = "genotype") %>%
  mutate(
    POS = BIN_POS * BIN_SIZE,
    method = factor(method, 
                   levels = c("K", "K_HMM", "Kasin", "Kasin_HMM", "Kgmm", "Kgmm_HMM"),
                   labels = c("K-means (weighted)", "K-means (weighted)\nHMM",
                              "K-means (arcsin)", "K-means (arcsin)\nHMM",
                              "Gaussian Mixture", "Gaussian Mixture]\nHMM"))
  ) %>%
  ggplot(aes(x = POS, y = 1, fill = genotype)) +
  geom_tile() +
  scale_fill_manual(values = pal) +
  facet_grid(method ~ CONTIG, scales = "free") +
  scale_x_continuous(labels = unit_format(unit = "M", scale = 1e-6)) +
  ggpubr::theme_classic2() +
  theme(
    legend.position = "bottom",
    strip.background = element_blank(),
    strip.text.x = element_text(hjust = 0),
    strip.text.y = element_text(angle = 0, face = "bold"),
    panel.spacing.x = unit(0.0, "lines"),
    panel.spacing.y = unit(0.0, "lines"),
    axis.line.y = element_blank(),
    axis.text.y = element_blank(),
    axis.line.x = element_blank(),
    axis.text.x = element_blank(),
    axis.title.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.title.y = element_blank(),
    axis.ticks.y = element_blank()
  ) +
  labs(
    title = paste("Comparison of Clustering Methods with HMM Smoothing (", BIN_SIZE_LABEL, " bins)", sep=""),
    x = "Genome Position (Mb)",
    fill = "Genotype"
  )
```

## Quantitative Method Assessment

### Genotype Frequency Analysis

```{r genotype-frequencies, fig.height=4}
# Create a summary of genotype frequencies for all methods
genotype_freq <- read_freq %>%
  pivot_longer(cols = c(K, Kasin, Kgmm, K_HMM, Kasin_HMM, Kgmm_HMM), 
               names_to = "method", 
               values_to = "genotype") %>%
  group_by(method, genotype) %>%
  summarize(
    count = n(),
    percentage = n() / nrow(read_freq) * 100,
    .groups = "drop"
  ) %>%
  mutate(
    method_type = ifelse(grepl("_HMM", method), "HMM Smoothed", "Original"),
    method_base = gsub("_HMM", "", method),
    method = case_when(
      method == "K" ~ "K-means (weighted)",
      method == "K_HMM" ~ "K-means (weighted) HMM",
      method == "Kasin" ~ "K-means (arcsin)",
      method == "Kasin_HMM" ~ "K-means (arcsin) HMM",
      method == "Kgmm" ~ "Gaussian Mixture",
      method == "Kgmm_HMM" ~ "Gaussian Mixture HMM",
      TRUE ~ method
    )
  )

# Add expected frequencies
expectation <- data.frame(
  method = "Expected (BC2S3)",
  genotype = c("REF", "HET", "ALT"),
  count = round(bc2s3 * nrow(read_freq), 0),
  percentage = 100 * bc2s3,
  method_type = "Theoretical",
  method_base = "Expected"
)

# Combine and create frequency table
method_freq <- rbind(expectation, genotype_freq) %>%
  select(method, genotype, percentage) %>%
  pivot_wider(
    id_cols = genotype,
    names_from = method,
    values_from = percentage
  )

# Display frequency table
method_freq %>%
  knitr::kable(
    caption = paste("Genotype frequencies (%) across methods (", BIN_SIZE_LABEL, " bins)", sep=""),
    digits = 1
  )

# Visualize frequencies
all_freq <- rbind(expectation, genotype_freq)
all_freq %>%
  ggplot(aes(x = method, y = percentage, fill = genotype)) +
  geom_bar(stat = "identity", position = "stack") +
  scale_fill_manual(values = pal) +
  labs(
    title = paste("Genotype frequencies across methods (", BIN_SIZE_LABEL, " bins)", sep=""),
    x = "Method",
    y = "Percentage (%)",
    fill = "Genotype"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "top"
  ) 
```

### Method Agreement Analysis

```{r method-agreement}
# Calculate agreement between methods including HMM versions
methods <- c("K", "Klog", "Kasin", "Kgmm", "K_HMM", "Klog_HMM", "Kasin_HMM", "Kgmm_HMM")
agreement_matrix <- matrix(NA, length(methods), length(methods))
colnames(agreement_matrix) <- methods
rownames(agreement_matrix) <- methods

for (i in 1:length(methods)) {
  for (j in 1:length(methods)) {
    agreement_matrix[i, j] <- mean(read_freq[[methods[i]]] == read_freq[[methods[j]]]) * 100
  }
}

# Display agreement matrix
knitr::kable(agreement_matrix, caption = "Percentage agreement between methods", digits = 1)

# Visualize agreement matrix
agreement_df <- as.data.frame(agreement_matrix) %>%
  tibble::rownames_to_column("Method1") %>%
  pivot_longer(-Method1, names_to = "Method2", values_to = "Agreement")

ggplot(agreement_df, aes(x = Method1, y = Method2, fill = Agreement)) +
  geom_tile() +
  geom_text(aes(label = round(Agreement, 1)), color = "white", size = 3) +
  scale_fill_gradient(low = "steelblue", high = "darkred") +
  labs(
    title = "Agreement Between Methods (%)",
    x = NULL,
    y = NULL,
    fill = "Agreement (%)"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.text = element_text(face = "bold"),
    panel.grid = element_blank()
  )
```

### HMM Smoothing Effect Quantification

```{r hmm-smoothing-effect}
# Calculate how much each method changed after HMM smoothing
hmm_effects <- data.frame(
  method = c("K", "Kasin", "Kgmm"),
  changes = c(
    mean(read_freq$K != read_freq$K_HMM) * 100,
    mean(read_freq$Kasin != read_freq$Kasin_HMM) * 100,
    mean(read_freq$Kgmm != read_freq$Kgmm_HMM) * 100
  )
)

# Calculate direction of changes (transitions between states)
transition_summary <- data.frame()

for (method in c("K", "Kasin", "Kgmm")) {
  hmm_method <- paste0(method, "_HMM")
  
  transitions <- table(read_freq[[method]], read_freq[[hmm_method]])
  
  # Calculate off-diagonal (changed) proportions
  total_changes <- sum(transitions) - sum(diag(transitions))
  
  for (i in rownames(transitions)) {
    for (j in colnames(transitions)) {
      if (i != j && transitions[i, j] > 0) {
        transition_summary <- rbind(transition_summary, data.frame(
          method = method,
          from = i,
          to = j,
          count = transitions[i, j],
          percentage = transitions[i, j] / nrow(read_freq) * 100
        ))
      }
    }
  }
}

# Display HMM effects
cat("Percentage of bins changed by HMM smoothing:\n")
hmm_effects %>%
  mutate(method = case_when(
    method == "K" ~ "K-means (weighted)",
    method == "Kasin" ~ "K-means (arcsin)",
    method == "Kgmm" ~ "Gaussian Mixture",
    TRUE ~ method
  )) %>%
  knitr::kable(col.names = c("Method", "% Bins Changed"), digits = 2)

# Display transition summary
cat("\nDetailed transition patterns:\n")
transition_summary %>%
  mutate(
    transition = paste(from, "=>", to),
    method = case_when(
      method == "K" ~ "K-means (weighted)",
      method == "Kasin" ~ "K-means (arcsin)",
      method == "Kgmm" ~ "Gaussian Mixture",
      TRUE ~ method
    )
  ) %>%
  select(method, transition, count, percentage) %>%
  knitr::kable(digits = 2)

# Visualize HMM effects
ggplot(hmm_effects, aes(x = reorder(method, changes), y = changes)) +
  geom_col(fill = "steelblue", alpha = 0.7) +
  geom_text(aes(label = paste0(round(changes, 1), "%")), 
            hjust = -0.1, size = 4) +
  labs(
    title = "Effect of HMM Smoothing on Different Clustering Methods",
    x = "Clustering Method",
    y = "Percentage of Bins Changed (%)"
  ) +
  theme_minimal() +
  coord_flip()
```

## Method Disagreement Analysis

```{r method-differences, fig.height=3}
# Analyze where methods disagree most
disagreement_data <- read_freq %>%
  mutate(
    POS = BIN_POS * BIN_SIZE,
    # Check if all original methods agree
    original_agreement = factor(ifelse(
      K == Kasin & K == Kgmm,
      "All methods agree",
      "Methods disagree"
    ), levels = c("All methods agree", "Methods disagree")),
    # Check if all HMM methods agree
    hmm_agreement = factor(ifelse(
      K_HMM == Kasin_HMM & K_HMM == Kgmm_HMM,
      "All methods agree",
      "Methods disagree"
    ), levels = c("All methods agree", "Methods disagree"))
  )

# Calculate disagreement statistics
original_disagreement <- mean(disagreement_data$original_agreement == "Methods disagree") * 100
hmm_disagreement <- mean(disagreement_data$hmm_agreement == "Methods disagree") * 100

cat("Original methods disagreement:", round(original_disagreement, 1), "%\n")
cat("HMM smoothed methods disagreement:", round(hmm_disagreement, 1), "%\n")
cat("Reduction in disagreement:", round(original_disagreement - hmm_disagreement, 1), "percentage points\n")

# Create tile plot showing disagreement regions
p1 <- ggplot(disagreement_data, aes(x = POS, y = 1, fill = original_agreement)) +
  geom_tile() +
  scale_fill_manual(values = c("darkgreen", "darkred")) +
  facet_grid(. ~ CONTIG, scales = "free_x") +
  scale_x_continuous(labels = unit_format(unit = "", scale = 1e-6)) +
  labs(title = "Original Methods Agreement/Disagreement", fill = NULL) +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    strip.background = element_blank(),
    axis.line.y = element_blank(),
    axis.text.y = element_blank(),
    axis.title = element_blank(),
    axis.ticks = element_blank(),
    panel.spacing.x = unit(0.0, "lines")
  )

p2 <- ggplot(disagreement_data, aes(x = POS, y = 1, fill = hmm_agreement)) +
  geom_tile() +
  scale_fill_manual(values = c("darkgreen", "darkred")) +
  facet_grid(. ~ CONTIG, scales = "free_x") +
  scale_x_continuous(labels = unit_format(unit = "", scale = 1e-6)) +
  labs(title = "HMM Smoothed Methods Agreement/Disagreement", 
       x = "Genome Position (Mb)", fill = NULL) +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    strip.background = element_blank(),
    axis.line.y = element_blank(),
    axis.text.y = element_blank(),
    axis.title.y = element_blank(),
    axis.ticks.y = element_blank(),
    panel.spacing.x = unit(0.0, "lines")
  )

ggpubr::ggarrange(p1, p2, ncol = 1, common.legend = TRUE)
```


## Conclusions and Recommendations

Based on this comprehensive analysis of ancestry calling methods with HMM smoothing:

### Key Findings

1. **Method Performance**: All clustering methods show reasonable performance, with the Gaussian Mixture Model and arcsin-transformed K-means showing slightly better separation of genotype classes.

2. **HMM Smoothing Benefits**: 
   - Reduces noise in ancestry calls by an average of `r round(mean(hmm_effects$changes), 1)`% across methods
   - Improves agreement between methods by `r round(original_disagreement - hmm_disagreement, 1)` percentage points
   - Enforces biological constraints based on breeding design expectations

3. **Genotype Frequency Alignment**: HMM smoothing brings observed frequencies closer to theoretical BC2S3 expectations, particularly for ALT regions.

### Recommendations

1. **Preferred Method**: Use the **Gaussian Mixture Model with HMM smoothing** (`Kgmm_HMM`) for final ancestry calls, as it:
   - Shows good separation between genotype classes
   - Incorporates breeding design priors through HMM
   - Produces frequencies closest to theoretical expectations

2. **Quality Control**: 
   - Monitor bins with very low variant counts (< 5 variants) for reliability
   - Consider chromosome-specific analysis for regions with high disagreement
   - Validate results with independent markers or phenotypic data when available

3. **Parameter Optimization**: 
   - HMM transition probabilities (currently 0.995 stay, 0.005 switch) may need adjustment based on:
     - Linkage map resolution
     - Expected recombination frequency
     - Specific breeding design

4. **Bin Size Considerations**: 
   - Current `r BIN_SIZE_LABEL` bins provide good balance between resolution and statistical power
   - Consider smaller bins (500kb) for fine-mapping or larger bins (5Mb) for genome-wide patterns

### Future Directions

1. **Multi-sample Joint Calling**: Implement joint HMM across multiple samples to leverage shared recombination patterns
2. **Copy Number Integration**: Incorporate copy number variation detection to improve accuracy in duplicated regions  
3. **Functional Annotation**: Overlay ancestry calls with gene annotations to identify functionally relevant introgression regions

## Session Information

```{r session-info}
# Record session information for reproducibility
sessionInfo()
```